
#include <ngx_config.h>
#include <ngx_core.h>
#include <ngx_http.h>

#include <string.h>

ngx_module_t ngx_http_mon_sys_module;

static void*
ngx_http_mon_sys_create_loc_conf(ngx_conf_t *ngx_conf);
static char*
ngx_http_mon_sys_merge_loc_conf(ngx_conf_t *ngx_conf, void *parent, void *child);
static char*
ngx_http_mon_sys(ngx_conf_t *ngx_conf, ngx_command_t *cmd, void *conf);
static ngx_int_t
ngx_http_mon_sys_handler(ngx_http_request_t *r);

/////////////////////////////////////////////////////////////////////
// configuration
typedef struct {
	// ngx_str_t test_str;
} ngx_http_mon_sys_conf_t;

/////////////////////////////////////////////////////////////////////
// command

static ngx_command_t ngx_http_mon_sys_commands[] = {
	{ ngx_string("mon_sys"),
		NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
		ngx_http_mon_sys,
		NGX_HTTP_LOC_CONF_OFFSET,
		0,
		NULL },

	ngx_null_command
};

static char*
ngx_http_mon_sys(ngx_conf_t *ngx_conf, ngx_command_t *cmd, void *conf)
{
	ngx_http_core_loc_conf_t *core_loc_conf;

	// ngx_http_mon_sys_conf_t *mon_sys_conf = conf;
	// mon_sys_conf->test_str = "Just a test.";

	core_loc_conf = ngx_http_conf_get_module_loc_conf(ngx_conf, ngx_http_core_module);
	// POINT 1:
	core_loc_conf->handler = ngx_http_mon_sys_handler;

	return NGX_CONF_OK;
}

static char* test_str = "Just a teset.\n";
static ngx_int_t
ngx_http_mon_sys_handler(ngx_http_request_t *r)
{
	ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
			"ngx_http_mon_sys_handler()");
	// POINT 2:
	// ngx_http_mon_sys_conf_t *conf =
	// 	ngx_http_get_module_loc_conf(r, ngx_http_mon_sys_module);

	// r->uri
	// r->args

	// ngx_http_headers_in_t
	// r->headers_in

	// send the header
	r->headers_out.status = NGX_HTTP_OK;
	r->headers_out.content_length_n = strlen(test_str);
	r->headers_out.content_type.len = sizeof("text/plain") - 1;
	r->headers_out.content_type.data = (u_char*)"text/plain";

	ngx_http_send_header(r);

	// send the body
	ngx_buf_t *b;
	ngx_chain_t out;

	b = ngx_pcalloc(r->pool, sizeof(ngx_buf_t));
	if (b == NULL) {
		ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
				"Failed to allocate response buffer.");
		return NGX_HTTP_INTERNAL_SERVER_ERROR;
	}

	b->pos  = (u_char*) test_str;
	b->last = (u_char*) test_str + strlen(test_str);

	b->memory = 1;	// readonly

	b->last_buf = 1;

	out.buf = b;
	out.next = NULL;

	return ngx_http_output_filter(r, &out);
}

/////////////////////////////////////////////////////////////////////
// context
static ngx_http_module_t ngx_http_mon_sys_module_ctx = {
	NULL,		// pre-configuration
	NULL,		// post-configuration

	NULL,		// create main configuration
	NULL,		// init main configuration

	NULL,		// create server configuration
	NULL,		// merge server configuration

	ngx_http_mon_sys_create_loc_conf,	// create location configuration
	ngx_http_mon_sys_merge_loc_conf,	// merge location configuration
};

static void*
ngx_http_mon_sys_create_loc_conf(ngx_conf_t *ngx_conf)
{
	ngx_http_mon_sys_conf_t *conf;

	conf = ngx_pcalloc(ngx_conf->pool, sizeof(ngx_http_mon_sys_conf_t));
	if (conf == NULL) {
		return NGX_CONF_ERROR;
	}

	return conf;
}

static char*
ngx_http_mon_sys_merge_loc_conf(ngx_conf_t *ngx_conf, void *parent, void *child)
{
	// ngx_http_mon_sys_conf_t *prev = parent;
	// ngx_http_mon_sys_conf_t *conf = child;

	// ngx_conf_merge_uint_value(conf->min_radius, prev->min_radius, 10);
	// if (conf->min_radius < 1) {
	//   ngx_conf_log_error(NGX_LOG_EMERG, ngx_conf, 0,
	//     "min_radius must be equal or more than 1");
	//   return NGX_CONF_ERROR;
	// }

	return NGX_CONF_OK;
}

/////////////////////////////////////////////////////////////////////
// module definition

ngx_module_t ngx_http_mon_sys_module = {
	NGX_MODULE_V1,
	&ngx_http_mon_sys_module_ctx,	// module context
	ngx_http_mon_sys_commands,		// module directives
	NGX_HTTP_MODULE,							// module type
	NULL,													// init master
	NULL,													// init module
	NULL,													// init process
	NULL,													// init thread
	NULL,													// exit thread
	NULL,													// exit process
	NULL,													// exit master
	NGX_MODULE_V1_PADDING
};


